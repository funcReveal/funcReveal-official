/**
 * 🚀 Auto-generated. Do not edit manually.
 */
export interface EffectSource {
  tsxCode: string;
  cssCode: string;
  githubUrl: string;
  TSXName: string;
  CSSName: string;
}

export const effectSources: Record<string, EffectSource> = {
  "animated-border": {
    "tsxCode": "import React from 'react';\r\nimport styles from './AnimatedBorder.module.css';\r\n\r\n/**\r\n * AnimatedBorder Component\r\n * ------------------------\r\n * Renders a circular placeholder with a rotating colorful glow ring behind it.\r\n * This is commonly used for avatars or badges with visual effects.\r\n */\r\nconst AnimatedBorder = () => {\r\n    return (\r\n        <div className={styles.container}>\r\n            {/* Colorful rotating glow behind the circle */}\r\n            <div className={styles.glow}></div>\r\n\r\n            {/* Foreground placeholder (can represent avatar) */}\r\n            <div className={styles.placeholder}></div>\r\n        </div>\r\n    );\r\n};\r\n\r\nexport default AnimatedBorder;\r\n",
    "cssCode": "/* =====================================\r\n   Container for the Circular Glow Effect\r\n   ===================================== */\r\n.container {\r\n  position: relative;\r\n  width: 160px;\r\n  height: 160px;\r\n  border-radius: 50%; /* Make the shape circular */\r\n  display: flex;\r\n  justify-content: center; /* Horizontally center the child */\r\n  align-items: center; /* Vertically center the child */\r\n}\r\n\r\n/* ==========================================\r\n   Rotating Rainbow Glow Effect (Outer Layer)\r\n   ========================================== */\r\n.glow {\r\n  position: absolute;\r\n  top: -12px;\r\n  left: -12px;\r\n  width: calc(100% + 24px); /* Expand beyond the container */\r\n  height: calc(100% + 24px);\r\n  border-radius: 50%; /* Keep it circular */\r\n  /* Rainbow gradient effect */\r\n  background: conic-gradient(red, orange, yellow, green, blue, purple, red);\r\n  filter: blur(12px); /* Soft blur for glow effect */\r\n  animation: spin 4s linear infinite; /* Infinite spinning animation */\r\n  z-index: 1; /* Positioned below the placeholder */\r\n}\r\n\r\n/* =====================================\r\n   Placeholder Circle (Simulated Avatar)\r\n   ===================================== */\r\n.placeholder {\r\n  width: 100%;\r\n  height: 100%;\r\n  border-radius: 50%; /* Circular shape */\r\n  background-color: #ef9c9c; /* Default inner fill (can be replaced) */\r\n  position: relative;\r\n  z-index: 2; /* Layered above the glow */\r\n}\r\n\r\n/* ======================\r\n   Keyframe: Spin Motion\r\n   ====================== */\r\n@keyframes spin {\r\n  0% {\r\n    transform: rotate(0deg);\r\n  }\r\n  100% {\r\n    transform: rotate(360deg);\r\n  }\r\n}\r\n",
    "githubUrl": "https://github.com/funcReveal/effects-gallery/tree/main/static-effects/animated-border",
    "TSXName": "AnimatedBorder.tsx",
    "CSSName": "AnimatedBorder.module.css"
  },
  "breathing-light": {
    "tsxCode": "import React from 'react';\r\nimport styles from './BreathingLight.module.css';\r\n\r\ninterface BreathingLightProps {\r\n    /** Diameter in px (default 24) */\r\n    size?: number;\r\n    /** Base glow color (default #00e5ff) */\r\n    color?: string;\r\n    /** Breathing cycle in seconds (default 3) */\r\n    duration?: number;\r\n}\r\n\r\nconst BreathingLight: React.FC<BreathingLightProps> = ({\r\n    size = 24,\r\n    color = '#00e5ff',\r\n    duration = 3,\r\n}) => {\r\n    // Pass CSS variables to the style prop.\r\n    const style: React.CSSProperties & Record<string, string> = {\r\n        '--size': `${size}px`,\r\n        '--color': color,\r\n        '--duration': `${duration}s`,\r\n    };\r\n    return <span className={styles.breathingLight} style={style} />;\r\n};\r\n\r\nexport default BreathingLight;",
    "cssCode": ".breathingLight {\r\n  /* Default CSS variables (override via inline style) */\r\n  --size: 24px; /* Diameter of the circle */\r\n  --color: #00e5ff; /* Base glow color */\r\n  --duration: 3s; /* One breathing cycle */\r\n\r\n  width: var(--size);\r\n  height: var(--size);\r\n  background: var(--color);\r\n  border-radius: 50%;\r\n  display: inline-block;\r\n  box-shadow: 0 0 8px currentColor;\r\n  animation: breathing var(--duration) ease-in-out infinite;\r\n}\r\n\r\n@keyframes breathing {\r\n  0%,\r\n  100% {\r\n    transform: scale(0.9);\r\n    opacity: 0.6;\r\n    box-shadow: 0 0 6px currentColor, 0 0 12px currentColor;\r\n  }\r\n  50% {\r\n    transform: scale(1.2);\r\n    opacity: 1;\r\n    box-shadow: 0 0 12px currentColor, 0 0 24px currentColor;\r\n  }\r\n}\r\n",
    "githubUrl": "https://github.com/funcReveal/effects-gallery/tree/main/static-effects/breathing-light",
    "TSXName": "BreathingLight.tsx",
    "CSSName": "BreathingLight.module.css"
  },
  "falling-particles": {
    "tsxCode": "import React, { useRef, useEffect } from 'react';\r\n\r\n// ✅ Import image assets for various particle types\r\nimport heart from './assets/heart.png';\r\nimport maple from './assets/maple.png';\r\nimport drop from './assets/drop.png';\r\nimport snowflake from './assets/snowflake.png';\r\nimport bubble from './assets/bubble.png';\r\nimport rain from './assets/rain.png';\r\nimport snow from './assets/snow.png';\r\nimport carnation from './assets/carnation.png';\r\n\r\nimport styles from './FallingParticles.module.css';\r\n\r\n// ✅ Props to control the behavior and appearance of falling particles\r\ninterface FallingParticlesProps {\r\n    count?: number; // Number of particles to display\r\n    speedRange?: [number, number]; // Particle falling speed range [min, max]\r\n    sizeRange?: [number, number]; // Particle size range [min, max]\r\n    types?: (\r\n        | 'heart'\r\n        | 'maple'\r\n        | 'drop'\r\n        | 'rain'\r\n        | 'bubble'\r\n        | 'snow'\r\n        | 'snowflake'\r\n        | 'carnation'\r\n        | 'all'\r\n    )[];\r\n    opacity?: number; // Opacity level for particles\r\n    rotate?: boolean; // Whether particles should rotate (swing left/right)\r\n    drift?: boolean; // Whether particles should drift sideways\r\n    angleInitial?: number; // Initial angle in degrees\r\n    rotateSwingRange?: number; // Rotation swing range in degrees\r\n    rotateSpeed?: number; // Speed of rotation animation\r\n    driftAmount?: number; // Sideways drift range\r\n    tiltWithDrift?: boolean; // Whether to tilt particles based on drift direction\r\n    textOverlay?: string;\r\n}\r\n\r\n// ✅ Map particle type strings to their corresponding image\r\nconst particleImageMap = {\r\n    heart,\r\n    maple,\r\n    drop,\r\n    snowflake,\r\n    snow,\r\n    bubble,\r\n    rain,\r\n    carnation,\r\n};\r\n\r\n// ✅ Internal structure to store individual particle state\r\ninterface Particle {\r\n    x: number;\r\n    y: number;\r\n    speed: number;\r\n    size: number;\r\n    img: HTMLImageElement;\r\n    driftX: number;\r\n    angle: number;\r\n    baseAngle: number;\r\n    angleRange: number;\r\n    angleSpeed: number;\r\n    angleTime: number;\r\n    textOverlay?: string;\r\n}\r\n\r\n// ✅ Return default properties for each particle type (used when not explicitly provided)\r\nfunction getDefaultsByType(type: string) {\r\n    switch (type) {\r\n        case 'rain':\r\n            return { rotate: false, drift: true, tiltWithDrift: true, speedRange: [1, 2], sizeRange: [2, 8], opacity: 1, rotateSwingRange: 0, rotateSpeed: 0, driftAmount: 0.3 };\r\n        case 'drop':\r\n            return { rotate: false, drift: true, tiltWithDrift: false, speedRange: [1, 2], sizeRange: [2, 8], opacity: 1, rotateSwingRange: 0, rotateSpeed: 0, driftAmount: 0.3 };\r\n        case 'heart':\r\n            return { rotate: true, drift: true, tiltWithDrift: false, speedRange: [0.1, 1], sizeRange: [20, 40], opacity: 0.85, rotateSwingRange: 15, rotateSpeed: 0.015, driftAmount: 0.2 };\r\n        case 'maple':\r\n            return { rotate: true, drift: true, tiltWithDrift: false, speedRange: [0.1, 0.2], sizeRange: [24, 48], opacity: 0.8, rotateSwingRange: 45, rotateSpeed: 0.03, driftAmount: 0.1 };\r\n        case 'bubble':\r\n            return { rotate: false, drift: true, tiltWithDrift: false, speedRange: [0.3, 0.8], sizeRange: [10, 20], opacity: 0.8, rotateSwingRange: 0, rotateSpeed: 0, driftAmount: 1.0 };\r\n        case 'carnation':\r\n            return { rotate: true, drift: true, tiltWithDrift: false, speedRange: [0.2, 1], sizeRange: [40, 80], opacity: 1, rotateSwingRange: 15, rotateSpeed: 0.010, driftAmount: 0.1 };\r\n        case 'snow':\r\n        case 'snowflake':\r\n            return { rotate: false, drift: true, tiltWithDrift: false, speedRange: [0.4, 0.6], sizeRange: [8, 16], opacity: 0.5, rotateSwingRange: 0, rotateSpeed: 0, driftAmount: 0.4 };\r\n        default:\r\n            return { rotate: true, drift: true, tiltWithDrift: false, speedRange: [0.2, 1], sizeRange: [40, 80], opacity: 1, rotateSwingRange: 15, rotateSpeed: 0.010, driftAmount: 0.1 };\r\n    }\r\n}\r\n\r\nconst FallingParticles: React.FC<FallingParticlesProps> = (props) => {\r\n    const canvasRef = useRef<HTMLCanvasElement | null>(null); // Canvas element for drawing\r\n    const containerRef = useRef<HTMLDivElement | null>(null); // Container that defines the drawing area size\r\n    const particlesRef = useRef<Particle[]>([]); // All current particles\r\n    const animationRef = useRef<number | null>(null); // Animation frame ID for canceling\r\n\r\n    // ✅ Extract props with fallback to defaults per type\r\n    const {\r\n        types = ['carnation'],\r\n        count = 50,\r\n        angleInitial = 0,\r\n    } = props;\r\n\r\n    const primaryType = types.includes('all') ? 'default' : types[0];\r\n    const defaults = getDefaultsByType(primaryType);\r\n\r\n    const rotate = props.rotate ?? defaults.rotate;\r\n    const drift = props.drift ?? defaults.drift;\r\n    const speedRange = props.speedRange ?? defaults.speedRange;\r\n    const sizeRange = props.sizeRange ?? defaults.sizeRange;\r\n    const opacity = props.opacity ?? defaults.opacity;\r\n    const rotateSwingRange = props.rotateSwingRange ?? defaults.rotateSwingRange;\r\n    const rotateSpeed = props.rotateSpeed ?? defaults.rotateSpeed;\r\n    const driftAmount = props.driftAmount ?? defaults.driftAmount;\r\n    const tiltWithDrift = props.tiltWithDrift ?? defaults.tiltWithDrift;\r\n\r\n    useEffect(() => {\r\n        const canvas = canvasRef.current;\r\n        const container = containerRef.current;\r\n        if (!canvas || !container) return;\r\n\r\n        const ctx = canvas.getContext('2d');\r\n        if (!ctx) return;\r\n\r\n        // ✅ Load image and return as HTMLImageElement\r\n        const loadImage = (src: string | { src: string }): Promise<HTMLImageElement> =>\r\n            new Promise((resolve, reject) => {\r\n                const img = new Image();\r\n                img.src = typeof src === 'string' ? src : src.src;\r\n                img.onload = () => resolve(img);\r\n                img.onerror = reject;\r\n            });\r\n\r\n        let resizeObserver: ResizeObserver;\r\n\r\n        const init = async () => {\r\n            try {\r\n                // ✅ Choose which particle images to load\r\n                const selectedTypes = types.includes('all') ? Object.keys(particleImageMap) : types;\r\n                const imageSources = selectedTypes.map(\r\n                    (type) => particleImageMap[type as keyof typeof particleImageMap]\r\n                );\r\n\r\n                const imgs = await Promise.all(imageSources.map(loadImage));\r\n\r\n                const resizeCanvas = () => {\r\n                    canvas.width = container.offsetWidth;\r\n                    canvas.height = container.offsetHeight;\r\n                };\r\n                resizeCanvas();\r\n\r\n                resizeObserver = new ResizeObserver(resizeCanvas);\r\n                resizeObserver.observe(container);\r\n\r\n                // ✅ Initialize particles\r\n                particlesRef.current = [];\r\n\r\n                for (let i = 0; i < count; i++) {\r\n                    const img = imgs[Math.floor(Math.random() * imgs.length)];\r\n                    const speed = randomBetween(speedRange[0], speedRange[1]);\r\n                    const angleRange = degToRad(mapValue(speed, speedRange[0], speedRange[1], rotateSwingRange, 5));\r\n                    const angleSpeed = mapValue(speed, speedRange[0], speedRange[1], rotateSpeed, 0.005);\r\n\r\n                    particlesRef.current.push({\r\n                        x: Math.random() * canvas.width,\r\n                        y: Math.random() * canvas.height, // 只在畫面上方 80% 高度隨機\r\n                        speed,\r\n                        size: randomBetween(sizeRange[0], sizeRange[1]),\r\n                        img,\r\n                        driftX: drift ? randomBetween(-driftAmount, driftAmount) : 0,\r\n                        angle: degToRad(angleInitial),\r\n                        baseAngle: degToRad(angleInitial),\r\n                        angleRange: rotate ? angleRange : 0,\r\n                        angleSpeed: rotate ? angleSpeed : 0,\r\n                        angleTime: Math.random() * Math.PI * 2,\r\n                    });\r\n                }\r\n\r\n                const animate = () => {\r\n                    ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n\r\n                    for (const p of particlesRef.current) {\r\n                        p.y += p.speed;\r\n                        if (drift) p.x += p.driftX;\r\n\r\n                        if (rotate) {\r\n                            p.angleTime += p.angleSpeed;\r\n                            p.angle = p.baseAngle + Math.sin(p.angleTime) * p.angleRange;\r\n                        }\r\n\r\n                        // ✅ Recycle particle if out of view\r\n                        if (p.y > canvas.height || p.x < -p.size || p.x > canvas.width + p.size) {\r\n                            p.y = -Math.random() * 100 - 50;\r\n                            p.x = Math.random() * canvas.width;\r\n                            p.angleTime = Math.random() * Math.PI * 2;\r\n                        }\r\n\r\n                        ctx.save();\r\n                        ctx.globalAlpha = opacity;\r\n                        ctx.filter = 'blur(1px)';\r\n\r\n                        if (rotate || tiltWithDrift) {\r\n                            ctx.translate(p.x + p.size / 2, p.y + p.size / 2);\r\n\r\n                            let totalAngle = 0;\r\n                            if (rotate) totalAngle += p.angle;\r\n                            if (tiltWithDrift) totalAngle += Math.atan2(-p.driftX, p.speed); // ✅ Tilt based on drift direction\r\n\r\n                            ctx.rotate(totalAngle);\r\n                            ctx.translate(-p.size / 2, -p.size / 2);\r\n                            ctx.drawImage(p.img, 0, 0, p.size, p.size);\r\n                        } else {\r\n                            ctx.drawImage(p.img, p.x, p.y, p.size, p.size);\r\n                        }\r\n\r\n                        ctx.restore();\r\n                    }\r\n                    if (props.textOverlay) {\r\n                        ctx.save();\r\n                        ctx.font = \"24px sans-serif\";\r\n                        ctx.fillStyle = \"rgba(255,255,255,0.9)\";\r\n                        ctx.textAlign = \"center\";\r\n                        ctx.fillText(props.textOverlay, canvas.width / 2, 50);\r\n                        ctx.restore();\r\n                    }\r\n\r\n                    animationRef.current = requestAnimationFrame(animate);\r\n                };\r\n\r\n                if (animationRef.current !== null) cancelAnimationFrame(animationRef.current);\r\n                animationRef.current = requestAnimationFrame(animate);\r\n            } catch (err) {\r\n                console.error('Failed to load images', err);\r\n            }\r\n        };\r\n\r\n        init();\r\n\r\n        return () => {\r\n            if (animationRef.current !== null) cancelAnimationFrame(animationRef.current);\r\n            if (resizeObserver) resizeObserver.disconnect();\r\n            particlesRef.current = [];\r\n        };\r\n    }, [\r\n        count,\r\n        speedRange,\r\n        sizeRange,\r\n        types,\r\n        opacity,\r\n        rotate,\r\n        drift,\r\n        angleInitial,\r\n        rotateSwingRange,\r\n        rotateSpeed,\r\n        driftAmount,\r\n        tiltWithDrift,\r\n        props.textOverlay,\r\n    ]);\r\n\r\n    return (\r\n        <div className={styles.container} ref={containerRef} >\r\n            <canvas\r\n                ref={canvasRef}\r\n                style={{\r\n                    width: '100%',\r\n                    height: '100%',\r\n                    pointerEvents: 'none', // ✅ Canvas does not interfere with mouse events\r\n                }}\r\n            />\r\n        </div>\r\n    );\r\n};\r\n\r\n// ✅ Generate a random number between two values\r\nfunction randomBetween(min: number, max: number) {\r\n    return min + Math.random() * (max - min);\r\n}\r\n\r\n// ✅ Convert degrees to radians for rotation calculations\r\nfunction degToRad(deg: number) {\r\n    return (deg * Math.PI) / 180;\r\n}\r\n\r\n// ✅ Remap a number from one range to another (used for scaling speed to angle/swing)\r\nfunction mapValue(value: number, inMin: number, inMax: number, outMin: number, outMax: number) {\r\n    const ratio = (value - inMin) / (inMax - inMin);\r\n    return outMin + ratio * (outMax - outMin);\r\n}\r\n\r\nexport default FallingParticles;\r\n",
    "cssCode": ".container {\r\n  position: relative; /* Allows the canvas inside to be absolutely positioned relative to this box */\r\n  width: 100%; /* Fixed width of the particle area */\r\n  height: 100%; /* Fixed height of the particle area */\r\n  overflow: hidden; /* Hide any particles that fall outside the box */\r\n  border: 1px solid #ccc; /* Light gray border for visibility */\r\n  background: linear-gradient(\r\n    to bottom,\r\n    #8883a5,\r\n    #4e4767\r\n  ); /* Light pink background color */\r\n  border-radius: 30px; /* Rounded corners for a soft look */\r\n  z-index: 1; /* Ensure this container stays above default layers */\r\n}\r\n",
    "githubUrl": "https://github.com/funcReveal/effects-gallery/tree/main/static-effects/falling-particles",
    "TSXName": "FallingParticles.tsx",
    "CSSName": "FallingParticles.module.css"
  },
  "glow-button": {
    "tsxCode": "import React from 'react';\r\nimport styles from './GlowButton.module.css'; // You can also use styled-components or Emotion\r\n\r\n/**\r\n * GlowButton Component\r\n * ---------------------\r\n * A button with a glowing hover effect using CSS animation.\r\n * Suitable for call-to-action or interactive UI elements.\r\n */\r\nconst GlowButton = () => {\r\n    return (\r\n        <button className={styles.glowButton}>\r\n            Hover Me\r\n        </button>\r\n    );\r\n};\r\n\r\nexport default GlowButton;\r\n",
    "cssCode": "/* =============================\r\n   Glowing Button with Hover Effect\r\n   ============================= */\r\n.glowButton {\r\n  padding: 1rem 2rem; /* Inner spacing */\r\n  font-size: 1rem; /* Text size */\r\n  border: none; /* Remove default border */\r\n  background: #111; /* Dark background */\r\n  color: white; /* Text color */\r\n  cursor: pointer; /* Show pointer on hover */\r\n  position: relative;\r\n  border-radius: 8px; /* Rounded corners */\r\n\r\n  /* Initial glow effect (both outer and inner) */\r\n  box-shadow: 0 0 10px #00f, /* Outer glow */ 0 0 20px #00f inset; /* Inner glow */\r\n\r\n  transition: box-shadow 0.3s ease; /* Smooth transition on hover */\r\n}\r\n\r\n/* =============================\r\n   Stronger glow on hover\r\n   ============================= */\r\n.glowButton:hover {\r\n  box-shadow: 0 0 20px #0ff, /* Stronger outer glow */ 0 0 30px #0ff inset; /* Stronger inner glow */\r\n}\r\n",
    "githubUrl": "https://github.com/funcReveal/effects-gallery/tree/main/undefined-effects/glow-button",
    "TSXName": "GlowButton.tsx",
    "CSSName": "GlowButton.module.css"
  }
};
