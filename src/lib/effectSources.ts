/**
 * ðŸš€ Auto-generated. Do not edit manually.
 */
export interface EffectSource {
  tsxCode: string;
  cssCode: string;
  githubUrl: string;
  TSXName: string;
  CSSName: string;
}

export const effectSources: Record<string, EffectSource> = {
  "animated-border": {
    "tsxCode": "import React from 'react';\r\nimport styles from './AnimatedBorder.module.css';\r\n\r\n/**\r\n * AnimatedBorder Component\r\n * ------------------------\r\n * Renders a circular placeholder with a rotating colorful glow ring behind it.\r\n * This is commonly used for avatars or badges with visual effects.\r\n */\r\nconst AnimatedBorder = () => {\r\n    return (\r\n        <div className={styles.container}>\r\n            {/* Colorful rotating glow behind the circle */}\r\n            <div className={styles.glow}></div>\r\n\r\n            {/* Foreground placeholder (can represent avatar) */}\r\n            <div className={styles.placeholder}></div>\r\n        </div>\r\n    );\r\n};\r\n\r\nexport default AnimatedBorder;\r\n",
    "cssCode": "/* =====================================\r\n   Container for the Circular Glow Effect\r\n   ===================================== */\r\n.container {\r\n  position: relative;\r\n  width: 160px;\r\n  height: 160px;\r\n  border-radius: 50%; /* Make the shape circular */\r\n  display: flex;\r\n  justify-content: center; /* Horizontally center the child */\r\n  align-items: center; /* Vertically center the child */\r\n}\r\n\r\n/* ==========================================\r\n   Rotating Rainbow Glow Effect (Outer Layer)\r\n   ========================================== */\r\n.glow {\r\n  position: absolute;\r\n  top: -12px;\r\n  left: -12px;\r\n  width: calc(100% + 24px); /* Expand beyond the container */\r\n  height: calc(100% + 24px);\r\n  border-radius: 50%; /* Keep it circular */\r\n  /* Rainbow gradient effect */\r\n  background: conic-gradient(red, orange, yellow, green, blue, purple, red);\r\n  filter: blur(12px); /* Soft blur for glow effect */\r\n  animation: spin 4s linear infinite; /* Infinite spinning animation */\r\n  z-index: 1; /* Positioned below the placeholder */\r\n}\r\n\r\n/* =====================================\r\n   Placeholder Circle (Simulated Avatar)\r\n   ===================================== */\r\n.placeholder {\r\n  width: 100%;\r\n  height: 100%;\r\n  border-radius: 50%; /* Circular shape */\r\n  background-color: #ef9c9c; /* Default inner fill (can be replaced) */\r\n  position: relative;\r\n  z-index: 2; /* Layered above the glow */\r\n}\r\n\r\n/* ======================\r\n   Keyframe: Spin Motion\r\n   ====================== */\r\n@keyframes spin {\r\n  0% {\r\n    transform: rotate(0deg);\r\n  }\r\n  100% {\r\n    transform: rotate(360deg);\r\n  }\r\n}\r\n",
    "githubUrl": "https://github.com/funcReveal/effects-gallery/tree/main/static-effects/animated-border",
    "TSXName": "AnimatedBorder.tsx",
    "CSSName": "AnimatedBorder.module.css"
  },
  "breathing-light": {
    "tsxCode": "import React from 'react';\r\nimport styles from './BreathingLight.module.css';\r\n\r\ninterface BreathingLightProps {\r\n    /** Diameter in px (default 24) */\r\n    size?: number;\r\n    /** Base glow color (default #00e5ff) */\r\n    color?: string;\r\n    /** Breathing cycle in seconds (default 3) */\r\n    duration?: number;\r\n}\r\n\r\nconst BreathingLight: React.FC<BreathingLightProps> = ({\r\n    size = 24,\r\n    color = '#00e5ff',\r\n    duration = 3,\r\n}) => {\r\n    // Pass CSSÂ variables to the style prop.\r\n    const style: React.CSSProperties & Record<string, string> = {\r\n        '--size': `${size}px`,\r\n        '--color': color,\r\n        '--duration': `${duration}s`,\r\n    };\r\n    return <span className={styles.breathingLight} style={style} />;\r\n};\r\n\r\nexport default BreathingLight;",
    "cssCode": ".breathingLight {\r\n  /* Default CSSÂ variables (override via inline style) */\r\n  --size: 24px; /* Diameter of the circle */\r\n  --color: #00e5ff; /* Base glow color */\r\n  --duration: 3s; /* One breathing cycle */\r\n\r\n  width: var(--size);\r\n  height: var(--size);\r\n  background: var(--color);\r\n  border-radius: 50%;\r\n  display: inline-block;\r\n  box-shadow: 0 0 8px currentColor;\r\n  animation: breathing var(--duration) ease-in-out infinite;\r\n}\r\n\r\n@keyframes breathing {\r\n  0%,\r\n  100% {\r\n    transform: scale(0.9);\r\n    opacity: 0.6;\r\n    box-shadow: 0 0 6px currentColor, 0 0 12px currentColor;\r\n  }\r\n  50% {\r\n    transform: scale(1.2);\r\n    opacity: 1;\r\n    box-shadow: 0 0 12px currentColor, 0 0 24px currentColor;\r\n  }\r\n}\r\n",
    "githubUrl": "https://github.com/funcReveal/effects-gallery/tree/main/static-effects/breathing-light",
    "TSXName": "BreathingLight.tsx",
    "CSSName": "BreathingLight.module.css"
  },
  "falling-particles": {
    "tsxCode": "import React, { useRef, useEffect, useMemo } from 'react';\r\n\r\n// Import particle image assets\r\nimport heart from './assets/heart.png';\r\nimport maple from './assets/maple.png';\r\nimport snowflake from './assets/snowflake.png';\r\nimport bubble from './assets/bubble.png';\r\nimport rain from './assets/rain.png';\r\nimport snow from './assets/snow.png';\r\nimport carnation from './assets/carnation.png';\r\n\r\nimport styles from './FallingParticles.module.css';\r\n\r\n// Props interface for the FallingParticles component\r\ninterface FallingParticlesProps {\r\n    count?: number; // Number of particles\r\n    speedRange?: [number, number]; // Particle falling speed range\r\n    sizeRange?: [number, number]; // Particle size range\r\n    type?: 'heart' | 'maple' | 'rain' | 'bubble' | 'snow' | 'snowflake' | 'carnation' | 'all';\r\n    opacity?: number; // Particle transparency (0 to 1)\r\n    rotate?: boolean; // Whether the particles rotate\r\n    drift?: boolean; // Whether particles drift left/right\r\n    angleInitial?: number; // Starting rotation angle\r\n    rotateSwingRange?: number; // Maximum angle of swing rotation\r\n    rotateSpeed?: number; // Speed of the swing rotation\r\n    driftAmount?: number; // Max drift per frame\r\n    tiltWithDrift?: boolean; // Whether particles tilt with drift direction\r\n    textOverlay?: string; // Optional text overlay on the canvas\r\n    background?: string; // Canvas background style\r\n}\r\n\r\n// Map each type to an image asset\r\nconst particleImageMap = {\r\n    heart,\r\n    maple,\r\n    snowflake,\r\n    snow,\r\n    bubble,\r\n    rain,\r\n    carnation,\r\n};\r\n\r\n// Particle object structure\r\ninterface Particle {\r\n    x: number;\r\n    y: number;\r\n    speed: number;\r\n    size: number;\r\n    img: HTMLImageElement;\r\n    driftX: number;\r\n    angle: number;\r\n    baseAngle: number;\r\n    angleRange: number;\r\n    angleSpeed: number;\r\n    angleTime: number;\r\n    textOverlay?: string;\r\n}\r\n\r\n// Default settings per particle type\r\nfunction getDefaultsByType(type: string) {\r\n    switch (type) {\r\n        case 'rain': return { count: 50, rotate: false, drift: true, tiltWithDrift: true, speedRange: [4, 5], sizeRange: [10, 20], opacity: 1, rotateSwingRange: 0, rotateSpeed: 0, driftAmount: 0.3 };\r\n        case 'heart': return { count: 20, rotate: true, drift: true, tiltWithDrift: false, speedRange: [0.1, 1], sizeRange: [50, 100], opacity: 0.52, rotateSwingRange: 15, rotateSpeed: 0.015, driftAmount: 0.2 };\r\n        case 'maple': return { count: 50, rotate: true, drift: true, tiltWithDrift: false, speedRange: [0.2, 1], sizeRange: [24, 48], opacity: 0.8, rotateSwingRange: 45, rotateSpeed: 0.03, driftAmount: 0.01 };\r\n        case 'bubble': return { count: 50, rotate: false, drift: true, tiltWithDrift: false, speedRange: [0.3, 0.8], sizeRange: [10, 20], opacity: 0.8, rotateSwingRange: 0, rotateSpeed: 0, driftAmount: 0.5 };\r\n        case 'carnation': return { count: 30, rotate: true, drift: true, tiltWithDrift: false, speedRange: [0.2, 1], sizeRange: [40, 80], opacity: 1, rotateSwingRange: 15, rotateSpeed: 0.010, driftAmount: 0.1 };\r\n        case 'snow': return { count: 50, rotate: false, drift: true, tiltWithDrift: false, speedRange: [0.4, 0.6], sizeRange: [8, 16], opacity: 0.2, rotateSwingRange: 0, rotateSpeed: 0, driftAmount: 0.5 };\r\n        case 'snowflake': return { count: 50, rotate: false, drift: true, tiltWithDrift: false, speedRange: [0.4, 0.6], sizeRange: [15, 30], opacity: 0.2, rotateSwingRange: 0, rotateSpeed: 0, driftAmount: 0.4 };\r\n        default: return { count: 50, rotate: true, drift: true, tiltWithDrift: false, speedRange: [0.2, 1], sizeRange: [40, 80], opacity: 1, rotateSwingRange: 15, rotateSpeed: 0.010, driftAmount: 0.1 };\r\n    }\r\n}\r\n\r\nconst FallingParticles: React.FC<FallingParticlesProps> = (props) => {\r\n    const canvasRef = useRef<HTMLCanvasElement | null>(null);\r\n    const containerRef = useRef<HTMLDivElement | null>(null);\r\n    const particlesRef = useRef<Particle[]>([]);\r\n    const animationRef = useRef<number | null>(null);\r\n\r\n    // Merge incoming props with default values based on particle type\r\n    const mergedProps = useMemo(() => {\r\n        const type = props.type ?? 'carnation';\r\n        const defaults = getDefaultsByType(type);\r\n        return {\r\n            type,\r\n            count: props.count ?? defaults.count,\r\n            speedRange: props.speedRange ?? defaults.speedRange,\r\n            sizeRange: props.sizeRange ?? defaults.sizeRange,\r\n            opacity: props.opacity ?? defaults.opacity,\r\n            rotate: props.rotate ?? defaults.rotate,\r\n            drift: props.drift ?? defaults.drift,\r\n            angleInitial: props.angleInitial ?? 0,\r\n            rotateSwingRange: props.rotateSwingRange ?? defaults.rotateSwingRange,\r\n            rotateSpeed: props.rotateSpeed ?? defaults.rotateSpeed,\r\n            driftAmount: props.driftAmount ?? defaults.driftAmount,\r\n            tiltWithDrift: props.tiltWithDrift ?? defaults.tiltWithDrift,\r\n            textOverlay: props.textOverlay,\r\n            background: props.background ?? 'transparent',\r\n        };\r\n    }, [props]);\r\n\r\n    // Keep the latest textOverlay value in a ref for consistent rendering\r\n    const textOverlayRef = useRef(mergedProps.textOverlay);\r\n    useEffect(() => {\r\n        textOverlayRef.current = mergedProps.textOverlay;\r\n    }, [mergedProps.textOverlay]);\r\n\r\n    // Particle animation and rendering logic\r\n    useEffect(() => {\r\n        const canvas = canvasRef.current;\r\n        const container = containerRef.current;\r\n        if (!canvas || !container) return;\r\n\r\n        const ctx = canvas.getContext('2d');\r\n        if (!ctx) return;\r\n\r\n        const loadImage = (src: string | { src: string }) =>\r\n            new Promise<HTMLImageElement>((resolve, reject) => {\r\n                const img = new Image();\r\n                img.src = typeof src === 'string' ? src : src.src;\r\n                img.onload = () => resolve(img);\r\n                img.onerror = reject;\r\n            });\r\n\r\n        let resizeObserver: ResizeObserver;\r\n\r\n        const init = async () => {\r\n            try {\r\n                const resolvedTypes: (keyof typeof particleImageMap)[] =\r\n                    mergedProps.type === 'all'\r\n                        ? Object.keys(particleImageMap) as (keyof typeof particleImageMap)[]\r\n                        : [mergedProps.type];\r\n\r\n                const imageSources = resolvedTypes.map(t => particleImageMap[t]);\r\n                const imgs = await Promise.all(imageSources.map(loadImage));\r\n\r\n                const resizeCanvas = () => {\r\n                    canvas.width = container.offsetWidth;\r\n                    canvas.height = container.offsetHeight;\r\n                };\r\n                resizeCanvas();\r\n                resizeObserver = new ResizeObserver(resizeCanvas);\r\n                resizeObserver.observe(container);\r\n\r\n                // Initialize particle data\r\n                particlesRef.current = [];\r\n                for (let i = 0; i < mergedProps.count; i++) {\r\n                    const img = imgs[Math.floor(Math.random() * imgs.length)];\r\n                    const speed = randomBetween(mergedProps.speedRange[0], mergedProps.speedRange[1]);\r\n                    const angleRange = degToRad(mapValue(speed, mergedProps.speedRange[0], mergedProps.speedRange[1], mergedProps.rotateSwingRange, 5));\r\n                    const angleSpeed = mapValue(speed, mergedProps.speedRange[0], mergedProps.speedRange[1], mergedProps.rotateSpeed, 0.005);\r\n\r\n                    particlesRef.current.push({\r\n                        x: Math.random() * canvas.width,\r\n                        y: Math.random() * canvas.height,\r\n                        speed,\r\n                        size: randomBetween(mergedProps.sizeRange[0], mergedProps.sizeRange[1]),\r\n                        img,\r\n                        driftX: mergedProps.drift ? randomBetween(-mergedProps.driftAmount, mergedProps.driftAmount) : 0,\r\n                        angle: degToRad(mergedProps.angleInitial),\r\n                        baseAngle: degToRad(mergedProps.angleInitial),\r\n                        angleRange: mergedProps.rotate ? angleRange : 0,\r\n                        angleSpeed: mergedProps.rotate ? angleSpeed : 0,\r\n                        angleTime: Math.random() * Math.PI * 2,\r\n                    });\r\n                }\r\n\r\n                const animate = () => {\r\n                    ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n\r\n                    for (const p of particlesRef.current) {\r\n                        p.y += p.speed;\r\n                        if (mergedProps.drift) p.x += p.driftX;\r\n\r\n                        if (mergedProps.rotate) {\r\n                            p.angleTime += p.angleSpeed;\r\n                            p.angle = p.baseAngle + Math.sin(p.angleTime) * p.angleRange;\r\n                        }\r\n\r\n                        if (p.y > canvas.height || p.x < -p.size || p.x > canvas.width + p.size) {\r\n                            p.y = -Math.random() * 100 - 50;\r\n                            p.x = Math.random() * canvas.width;\r\n                            p.angleTime = Math.random() * Math.PI * 2;\r\n                        }\r\n\r\n                        ctx.save();\r\n                        ctx.globalAlpha = mergedProps.opacity;\r\n                        ctx.filter = 'blur(1px)';\r\n\r\n                        if (mergedProps.rotate || mergedProps.tiltWithDrift) {\r\n                            ctx.translate(p.x + p.size / 2, p.y + p.size / 2);\r\n                            let totalAngle = 0;\r\n                            if (mergedProps.rotate) totalAngle += p.angle;\r\n                            if (mergedProps.tiltWithDrift) totalAngle += Math.atan2(-p.driftX, p.speed);\r\n                            ctx.rotate(totalAngle);\r\n                            ctx.translate(-p.size / 2, -p.size / 2);\r\n                            ctx.drawImage(p.img, 0, 0, p.size, p.size);\r\n                        } else {\r\n                            ctx.drawImage(p.img, p.x, p.y, p.size, p.size);\r\n                        }\r\n\r\n                        ctx.restore();\r\n                    }\r\n\r\n                    // Draw overlay text\r\n                    const overlayText = textOverlayRef.current;\r\n                    if (overlayText) {\r\n                        ctx.save();\r\n                        ctx.font = '24px sans-serif';\r\n                        ctx.fillStyle = 'rgba(0,0,0,0.7)';\r\n                        ctx.textAlign = 'center';\r\n                        ctx.fillText(overlayText, canvas.width / 2, 50);\r\n                        ctx.restore();\r\n                    }\r\n\r\n                    animationRef.current = requestAnimationFrame(animate);\r\n                };\r\n\r\n                if (animationRef.current !== null) cancelAnimationFrame(animationRef.current);\r\n                animationRef.current = requestAnimationFrame(animate);\r\n            } catch (err) {\r\n                console.error('Failed to load images', err);\r\n            }\r\n        };\r\n\r\n        init();\r\n\r\n        return () => {\r\n            if (animationRef.current !== null) cancelAnimationFrame(animationRef.current);\r\n            if (resizeObserver) resizeObserver.disconnect();\r\n            particlesRef.current = [];\r\n        };\r\n    }, [mergedProps]);\r\n\r\n    return (\r\n        <div className={styles.container} ref={containerRef}>\r\n            <canvas\r\n                ref={canvasRef}\r\n                style={{\r\n                    width: '100%',\r\n                    height: '100%',\r\n                    pointerEvents: 'none', // Let clicks pass through the canvas\r\n                    background: mergedProps.background,\r\n                }}\r\n            />\r\n        </div>\r\n    );\r\n};\r\n\r\n// Random number helper\r\nfunction randomBetween(min: number, max: number) {\r\n    return min + Math.random() * (max - min);\r\n}\r\n\r\n// Convert degrees to radians\r\nfunction degToRad(deg: number) {\r\n    return (deg * Math.PI) / 180;\r\n}\r\n\r\n// Map value from one range to another\r\nfunction mapValue(value: number, inMin: number, inMax: number, outMin: number, outMax: number) {\r\n    const ratio = (value - inMin) / (inMax - inMin);\r\n    return outMin + ratio * (outMax - outMin);\r\n}\r\n\r\nexport default FallingParticles;\r\n",
    "cssCode": ".container {\r\n  position: relative; /* Allows the canvas inside to be absolutely positioned relative to this box */\r\n  width: 100%; /* Fixed width of the particle area */\r\n  height: 100%; /* Fixed height of the particle area */\r\n  overflow: hidden; /* Hide any particles that fall outside the box */\r\n  border: 1px solid #ccc; /* Light gray border for visibility */\r\n  background: linear-gradient(\r\n    to bottom,\r\n    #8883a5,\r\n    #4e4767\r\n  ); /* Light pink background color */\r\n  border-radius: 30px; /* Rounded corners for a soft look */\r\n  z-index: 1; /* Ensure this container stays above default layers */\r\n}\r\n",
    "githubUrl": "https://github.com/funcReveal/effects-gallery/tree/main/static-effects/falling-particles",
    "TSXName": "FallingParticles.tsx",
    "CSSName": "FallingParticles.module.css"
  },
  "glow-button": {
    "tsxCode": "import React from 'react';\r\nimport styles from './GlowButton.module.css'; // You can also use styled-components or Emotion\r\n\r\n/**\r\n * GlowButton Component\r\n * ---------------------\r\n * A button with a glowing hover effect using CSS animation.\r\n * Suitable for call-to-action or interactive UI elements.\r\n */\r\nconst GlowButton = () => {\r\n    return (\r\n        <button className={styles.glowButton}>\r\n            Hover Me\r\n        </button>\r\n    );\r\n};\r\n\r\nexport default GlowButton;\r\n",
    "cssCode": "/* =============================\r\n   Glowing Button with Hover Effect\r\n   ============================= */\r\n.glowButton {\r\n  padding: 1rem 2rem; /* Inner spacing */\r\n  font-size: 1rem; /* Text size */\r\n  border: none; /* Remove default border */\r\n  background: #111; /* Dark background */\r\n  color: white; /* Text color */\r\n  cursor: pointer; /* Show pointer on hover */\r\n  position: relative;\r\n  border-radius: 8px; /* Rounded corners */\r\n\r\n  /* Initial glow effect (both outer and inner) */\r\n  box-shadow: 0 0 10px #00f, /* Outer glow */ 0 0 20px #00f inset; /* Inner glow */\r\n\r\n  transition: box-shadow 0.3s ease; /* Smooth transition on hover */\r\n}\r\n\r\n/* =============================\r\n   Stronger glow on hover\r\n   ============================= */\r\n.glowButton:hover {\r\n  box-shadow: 0 0 20px #0ff, /* Stronger outer glow */ 0 0 30px #0ff inset; /* Stronger inner glow */\r\n}\r\n",
    "githubUrl": "https://github.com/funcReveal/effects-gallery/tree/main/undefined-effects/glow-button",
    "TSXName": "GlowButton.tsx",
    "CSSName": "GlowButton.module.css"
  }
};
